{% extends "layout.html" %}

{% block additional_css %}

     <!-- Link to leaflet CSS and javascript for maps-->
    <link rel="stylesheet" href="/static/css/leaflet.css"/>
    <script src="static/js/leaflet.js"></script>
    <!-- Link to providers CSS and javascript for leaflet provider extension-->
    <script src="static/js/leaflet-providers.js"></script>
    <!-- Link to graticle extension-->
    <script src="static/js/Leaflet.Graticule.js"></script>

    <title>Mission {{ mission.Number }}</title>

    <!-- Palmer stuff here-->
    <script src="static/js/jquery-1.7.2.js"></script>
    <script src="static/js/leaflet.boatmarker.js"></script>
    <!-- Require vessel_homepage.js where the function $.getData() is defined -->
	<script type="text/javascript" src="https://www.nbp.usap.gov/include/js/suncalc.js"></script>
	<script type="text/javascript" src="https://www.nbp.usap.gov/include/js/moment.min.js"></script>
	<script type="text/javascript" src="https://www.nbp.usap.gov/include/vessel_homepage.js"></script>
    <script>
	// ------------ Global Vars ---------------
	var host = document.location.host;
	var course = 0.0;
	var controlPanel;
	var gps; // current ship's positoin (global so we can use it in multiple places)
	var dasngTrackline; // ship trackline based on dasNG on hermes
	var realtimeTrackline; // ship trackline realtime in-browser data
	var shipMarker;  // marker for the ship
	var wptMarker;  // waypoint for the marker for the ship
	var showControls = false; // bool to show the map controls or not
	var fallowShip = false; // whether to keep the map centerd on the ship during refresh
	var autozoom = false; // bool whether to zoom to the ship and the next waypoint

    function getParameterByName(name, url)
	// Get URL query parameters
	// Name is the name of the URL paramter you want to get the value for, and URL is a URL (will use the current page if null)
	{
		if (!url) url = window.location.href;
		name = name.replace(/[\[\]]/g, "\\$&");
		var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
			results = regex.exec(url);
		if (!results) return null;
		if (!results[2]) return '';
		decoded = decodeURIComponent(results[2].replace(/\+/g, " "));
		if (decoded.toUpperCase() == 'TRUE') return true;
		if (decoded.toUpperCase() == 'FASLE') return false;
		return decodeURIComponent(results[2].replace(/\+/g, " "));
	}
    function getCurrentPosition()
	// Get the ship's current position, and return a L.LatLng object
	{
					var lat = $.getData("NBPs330Lat",6);
					var lng = $.getData("NBPs330Lon",6);
					// if longitude is negative, move it to 0-360 instead of -180 to 180 range
					// Disabled NBP1707 - found a better way!
					//if (lng < 0) {lng = (parseFloat(lng) + 180) + 180;}
					gps = new L.LatLng(parseFloat(lat),parseFloat(lng));
					return gps;
	}
    </script>

{% endblock %}

{% block extra_nav %}

<li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        Select Mission
    </a>
    <div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
        {% for m in mission_list %}
            <a class="dropdown-item" href="/mission{{ m.Number }}" >Mission {{ m.Number }} {{ m.Name }}</a>
        {% endfor %}
    </div>
</li>
    {% for glider_dives_list in dives_by_glider_json_dupe %}
<li class="nav-item dropdown">

        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            SG{{ glider_dives_list['features'][0]['properties']['gliderNum'] }} Select Dive
        </a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
            {% for d in glider_dives_list['features'] %}
                <a class="dropdown-item" href={{ d["properties"]["diveLink"] }} >Dive {{ d["properties"]["diveNum"] }}</a>
            {% endfor %}
        </div>
</li>

    {% endfor %}
{% endblock %}

{% block main_content %}

    <div class="totals">
        <h3>
            Mission {{ mission.Number}} {{ mission.Name }}
        </h3>
        {{ mission.Info|safe}} <br>
        Start {{ mission.StartDate.strftime("%Y-%m-%d") }}<br> End {{ mission.EndDate.strftime("%Y-%m-%d") }}
    </div>

    <div class="quicklinks">
        {% for g in recentdivesdict["features"]%}

            <a href="{{ g["properties"]["diveLink"] }}" class="btn btn-primary" role="button">SG{{ g["properties"]["gliderNum"] }} latest dive</a>
        {% endfor %}
    </div>



    <div class="mapbox">
     <!-- Create a map div -->
    <div id="map" style="height: 800px; "></div>
    <!-- Script to create a leaflet map-->
    <script nonce="{{ nonce }}">




    // geojson layers passed from view method
    let targetDict = JSON.parse('{{ targetdict| tojson | safe}}');
    let waypointDict = JSON.parse('{{ waypointdict| tojson | safe}}');
    let divesDict = JSON.parse('{{ dives_by_glider_json| tojson | safe}}');
    let linesDict = JSON.parse('{{ lines_by_glider_json| tojson | safe}}');
    let latestDivesDict = JSON.parse('{{ recentdivesdict| tojson | safe}}');
    // Argos tag fun zone
    let locsDict_good = JSON.parse('{{ locs_by_tag_json[0]| tojson | safe}}');
    let locsLinesDict_good = JSON.parse('{{ lines_by_tag_json[0]| tojson | safe}}');
    let latestLocsDict_good = JSON.parse('{{ recentlocsdict[0]| tojson | safe}}');
    let locsDict_med = JSON.parse('{{ locs_by_tag_json[1]| tojson | safe}}');
    let locsLinesDict_med = JSON.parse('{{ lines_by_tag_json[1]| tojson | safe}}');
    let latestLocsDict_med = JSON.parse('{{ recentlocsdict[1]| tojson | safe}}');
    let locsDict_bad = JSON.parse('{{ locs_by_tag_json[2]| tojson | safe}}');
    let locsLinesDict_bad = JSON.parse('{{ lines_by_tag_json[2]| tojson | safe}}');
    let latestLocsDict_bad = JSON.parse('{{ recentlocsdict[2]| tojson | safe}}');
    // end Argos tag fun zone
    let depth50 = JSON.parse('{{ isobath_dict["depth_50_m"] | tojson | safe}}');
    let depth200 = JSON.parse('{{ isobath_dict["depth_200_m"] | tojson | safe}}');
    let depth500 = JSON.parse('{{ isobath_dict["depth_500_m"] | tojson | safe}}');
    let depth1000 = JSON.parse('{{ isobath_dict["depth_1000_m"] | tojson | safe}}');
    let map = L.map('map')

    // Palmer stuff
    var init_lat = getParameterByName('lat') || $.getData("NBPs330Lat",6);; // initial lat
    var init_lon = getParameterByName('lon') || $.getData("NBPs330Lon",6); // initial lon
    var startposition = new L.LatLng(parseFloat(init_lat),parseFloat(init_lon));

		// Set initial map view (center & zoom)
    map.setView(startposition, 9);
    var shipIcon = new L.BoatIcon();
    shipIcon.setHeadingWind($.getData("NBPGyroHeading",1),$.getData("NBPSUSTrueWindSpdKn",1),$.getData("NBPSUSTrueWindDir",1));
    shipMarker = new L.marker(getCurrentPosition(), {icon: shipIcon});
    shipMarker.addTo(map);
    // A series of optional map layers. ortho has addTo(map) so is on by default


    let osm =  L.tileLayer("https://maps.nbp.usap.gov/maptiles/osm-intl/{z}/{x}/{y}.png",
        {maxZoom: 18, attribution: "Â© OpenStreetMap", errorTileUrl: '/maptiles/transparent-tile.png'}).addTo(map);
    // Graticule for lon and lat lines on map

    let graticule = L.latlngGraticule({
        showLabel: true,
        weight: 0.8,
        fontColor: 'white',
        zoomInterval: [
            {start: 3, end: 4, interval: 30},
            {start: 5, end: 5, interval: 10},
            {start: 6, end: 6, interval: 5},
            {start: 7, end: 8, interval: 3},
            {start: 9, end: 9, interval: 1},
            {start: 9, end: 10, interval: 0.5},
            {start: 11, end: 11, interval: 0.25},
            {start: 12, end: 13, interval: 1/12},
        ]
    })

    // Optional high lat graticule with finer graduations in lat
    let graticuleHighLat = L.latlngGraticule({
        showLabel: true,
        weight: 0.8,
        fontColor: 'white',
        zoomInterval:
            { latitude: [
                    {start: 3, end: 4, interval: 10},
                    {start: 5, end: 5, interval: 3},
                    {start: 6, end: 6, interval: 2},
                    {start: 7, end: 8, interval: 1},
                    {start: 9, end: 9, interval: 0.25},
                    {start: 9, end: 10, interval: 0.25},
                    {start: 11, end: 11, interval: 1/12},
                    {start: 12, end: 13, interval: 1/30},

    ],
        longitude: [
            {start: 3, end: 4, interval: 30},
            {start: 5, end: 5, interval: 10},
            {start: 6, end: 6, interval: 5},
            {start: 7, end: 8, interval: 3},
            {start: 9, end: 9, interval: 1},
            {start: 9, end: 10, interval: 0.5},
            {start: 11, end: 11, interval: 0.25},
            {start: 12, end: 13, interval: 1/12},

    ]}

    }).addTo(map);

    // Add basemap layers to mao
    let basemaps = {
        OpenStreetMap: osm,
    };

    // Argos tag zone

    let locsIcon = L.icon({
        iconUrl: '/static/img/icons/argos.png',
        shadowUrl: '/static/img/icons/targetshadow.png',
        iconSize:     [32, 26], // size of the icon
        shadowSize:   [32, 32], // size of the shadow
        iconAnchor:   [16, 26], // point of the icon which will correspond to marker's location
        shadowAnchor: [10, 31],  // the same for the shadow
        popupAnchor:  [0, -30] // point from which the popup should open relative to the iconAnchor
    });

    // Argos tag layers in style of glider layers

    let tagsLayerGood = L.layerGroup([L.geoJSON(latestLocsDict_good, {
		pointToLayer: function (feature, latlng) {
			return L.marker(latlng, {icon: locsIcon});
		},
		onEachFeature: popupText
	}),

    L.geoJson(locsLinesDict_good, {style: {weight: 1, color:'red', dashArray: '10, 3'}}),

     L.geoJson(locsDict_good, {
        pointToLayer: function (feature, latlng) {
            return new L.CircleMarker(latlng, {radius: 5,
                fillOpacity: 0.8,
                color: 'black',
                fillColor: 'red',
                weight: 1,});
        },
        onEachFeature: popupText
    })])


    let tagsLayerMed = L.layerGroup([L.geoJSON(latestLocsDict_med, {
        pointToLayer: function (feature, latlng) {
            return L.marker(latlng, {icon: locsIcon});
        },
        onEachFeature: popupText
    }),

        L.geoJson(locsLinesDict_med, {style: {weight: 1, color:'orange', dashArray: '10, 3'}}),

        L.geoJson(locsDict_med, {
            pointToLayer: function (feature, latlng) {
                return new L.CircleMarker(latlng, {radius: 5,
                    fillOpacity: 0.8,
                    color: 'black',
                    fillColor: 'orange',
                    weight: 1,});
            },
            onEachFeature: popupText
        })])


    let tagsLayerBad = L.layerGroup([L.geoJSON(latestLocsDict_bad, {
        pointToLayer: function (feature, latlng) {
            return L.marker(latlng, {icon: locsIcon});
        },
        onEachFeature: popupText
    }),

        L.geoJson(locsLinesDict_bad, {style: {weight: 1, color:'black', dashArray: '10, 3'}}),

        L.geoJson(locsDict_bad, {
            pointToLayer: function (feature, latlng) {
                return new L.CircleMarker(latlng, {radius: 5,
                    fillOpacity: 0.8,
                    color: 'black',
                    fillColor: 'black',
                    weight: 1,});
            },
            onEachFeature: popupText
        })])
    // Optional layers that plot on top of the basemap
    let mapLayers = {

        "Ocean shading": L.tileLayer("https://maps.nbp.usap.gov/maptiles/ocean_tiles/{z}/{y}/{x}.png",
            {maxZoom: 16, attribution: "Â© Esri, USGS, NOAA", errorTileUrl: '/static/img/transparent-tile.png'}),
	    Labels: L.tileLayer("https://maps.nbp.usap.gov/maptiles/label_tiles/{z}/{y}/{x}.png",
            {maxZoom: 8, attribution: "Â© Esri, USGS, NOAA", errorTileUrl: '/maptiles/transparent-tile.png'}),

	    // This has has ocean features
	    // Bathymetry layer for the southern ocean (below 60S)  Created by J. Race and C. Linden during NBP1704.  There are notes in the admin wiki about how this was done.
	    Bathymetry: L.tileLayer("https://maps.nbp.usap.gov/maptiles/Bathymetry/{z}/{x}/{y}.png",
            {minZoom: 1, maxZoom: 12, attribution: "GEBCO", errorTileUrl: '/maptiles/transparent-tile.png'}),
	    // Layer showing the EEZs for the world
	    EEZ: L.tileLayer("https://dasng.nbp.usap.gov/BetterMap/Charts/EEZ/{z}/{x}/{y}.png",
            {minZoom: 0, maxZoom: 8, errorTileUrl: '/maptiles/transparent-tile.png'}),

        "<span style='color: red'>GEBCO 50 m</span>": L.geoJSON(depth50, {
            attribution: "GEBCO & C Rollo",
            color:'red',
        }),

         "<span style='color: #99CCFF'>GEBCO 200 m</span>": L.geoJSON(depth200, {
            attribution: "GEBCO & C Rollo",
             color:'#99CCFF',
        }),

        "<span style='color: blue'>GEBCO 500 m</span>": L.geoJSON(depth500, {
            attribution: "GEBCO & C Rollo",
            color:'blue',
        }),

         "<span style='color: gray'>GEBCO 1000 m</span>": L.geoJSON(depth1000, {
             attribution: "GEBCO & C Rollo",
             color:'gray',
        }),

        Graticule: graticule,

        "Graticule (high lat)": graticuleHighLat,
        "<span style='color: red'>Argos tags < 250 m ð </span>": tagsLayerGood,
        "<span style='color: orange'>Argos tags < 1500 m  ð </span> ": tagsLayerMed,
        "<span style='color: black'>All Argos tags ð¥ </span>": tagsLayerBad,

    };
    // Add the targets and seaglider icons

	let targetIcon = L.icon({
		iconUrl: '/static/img/icons/target.png',
		shadowUrl: '/static/img/icons/targetshadow.png',
		iconSize:     [16, 32], // size of the icon
		shadowSize:   [32, 32], // size of the shadow
		iconAnchor:   [8, 31], // point of the icon which will correspond to marker's location
		shadowAnchor: [6, 31],  // the same for the shadow
		popupAnchor:  [0, -30] // point from which the popup should open relative to the iconAnchor
	});

	let seagliderIcon = L.icon({
		iconUrl: '/static/img/icons/seaglider.png',
		shadowUrl: '/static/img/icons/seaglidershadow.png',
		iconSize:     [40, 30], // size of the icon
		shadowSize:   [55, 30], // size of the shadow
		iconAnchor:   [20, 29], // point of the icon which will correspond to marker's location
		shadowAnchor: [20, 30],  // the same for the shadow
		popupAnchor:  [3, -30] // point from which the popup should open relative to the iconAnchor
	});


    // Function adds popup content to markers
	function popupText(feature, layer) {
		layer.bindPopup(feature.properties.popupContent);
	}

    // Use the target icon on each target and add popup content
	let targetsLayer = L.geoJSON(targetDict, {
		pointToLayer: function (feature, latlng) {
			return L.marker(latlng, {icon: targetIcon});
		},
		onEachFeature: popupText
	}).addTo(map);


	let waypointLayer = L.geoJSON(waypointDict, {
		onEachFeature: popupText
	}).addTo(map);



    // Adding all dive connecting lines to map. Fillcolor by glider number

    function style(feature) {
        return {
            weight: 1,
            color: getColor(feature.properties.gliderOrder),
        };
    }
    L.geoJson(linesDict, {style: style}).addTo(map);

	// setting color from geojson. We have enough unique colors for 8 gliders. After that they'll all be white
        function getColor(style) {
          switch (style) {
            case 0:
              return "#ff7f0e" ;
            case 1:
              return "#4ac6a9";
            case 2:
              return '#d71f2c';
            case 3:
              return '#8aff5e';
            case 4:
              return '#d910be';
            case 5:
              return '#daff00';
            case 6:
              return '#07010a';
            default:
              return 'black';
          }
        }

        // Adding all dives to map. Fillcolor by glider number, adding popup text
        let divesLayer = L.geoJson(divesDict, {
            pointToLayer: function (feature, latlng) {
            return new L.CircleMarker(latlng, {radius: 5,
                                                fillOpacity: 0.8,
                                                color: 'black',
                                                fillColor: getColor(feature.properties.gliderOrder),
                                                weight: 1,});
            },
         onEachFeature: popupText
        }).addTo(map);


    // Use the seaglider icon on most recent dive by each glider and add popup content
	let seagliderLayer = L.geoJSON(latestDivesDict, {
		pointToLayer: function (feature, latlng) {
			return L.marker(latlng, {icon: seagliderIcon});
		},
		onEachFeature: popupText
	}).addTo(map);





    // Controls for the map
    L.control.layers(basemaps, mapLayers).addTo(map);
    // Length scale with max width in pixels
    L.control.scale({maxWidth: 200}).addTo(map)
    </script>
    </div>



{% endblock %}

